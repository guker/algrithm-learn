#最大流的Ford-Fulkerson方法
## 最大流
图G(V,E)的最大流是只从原点流出的流量的最大值。
举例而言，如果网络中的容量除了源外都是无穷大，
那么最大流就是从源所能流出的最大流，等于与源相连的边
的容量之和。但是，由于网络中的中间节点不是无穷，
最大流将首先于中间节点的边的容量。
下面有个定理，是说最大流等于最小切的容量。


## 残留网络 Residual networks
* *残留网络*的概念，流网络G和流f，残留网络G_f由残留容量的边组成。
c_f(u,v) = c(u,v) - f(u,v)。说的是网络中剩余的容量和边所构成的网络，称为残留网络 Residual networks。
那些流等于容量的边，由于残留容量为0，故不再残留网络中。
* *残留网络*G_f也可能包含不在原网络G中的边！？
 
## 增广路径 Augmenting paths
增广路径是指残留网络中一条从源到目标容量不为0的路径。
路劲的容量是由这条路径上正向容量的最小值来定义。
如果是不存在的路径，容量自然为0。



## 流网络的切 cut
流网络 G=(V,E)的切是指对顶点集合的一个划分 (S,T)，S+T=V。f是G上的流，那么切的流
![切的流](http://chart.apis.google.com/chart?cht=tx&chl=f(S%2CT)%20%3D%20%5Csum_%7Bu%20%5Cin%20S%7D%20%5Csum_%7Bv%20%5Cin%20T%7D%20f(u%2Cv)%20-%20%20%5Csum_%7Bu%20%5Cin%20S%7D%20%5Csum_%7Bv%20%5Cin%20T%7D%20f(v%2Cu))
其实就是从S流入T的净流量之和。

而切的容量则为从S到T的容量之和。
![切的容量](http://chart.apis.google.com/chart?cht=tx&chl=c(S%2CT)%20%3D%20%5Csum_%7Bu%20%5Cin%20S%7D%20%5Csum_%7Bv%20%5Cin%20T%7D%20c(u%2Cv)%20)

## 最大流-最小切定理 Max-flow min-cut theorem
最小切就是指容量最小的切(S,T)。容易相当，由于流的守恒，
对于任意一个切，它的流等于整个网络的流。
而他的流不能超过它的容量，所以最大流不会超过最小切的容量。
事实上，最大流-最小切定理表明这个上界是可以达到的。
即最大流等于最小切的容量。

再考虑这个最小切，当流等于最小切的容量时，
那么从S到T的任意一边都是满载荷的。
即这些边的流等于它的容量。那么，在残留网络中，
这些正向的边(S->T)是不存在的（或容量为0），
只有反向的边，因而不存在一条正向边从S->T，
所以也不存在一条从源到目标的增广路径！
对于从T->S的反向边，满足最大流时，方向流量为0，
否则也会存在一条增广路径，并且可以继续减少反向流量
来增加正向流量。

## Ford-Fulkerson算法
Ford-Fulkerson算法通过搜寻一条增广路径（用BFS或者DFS，时间复杂度为O(E)），
如果搜到则增加该路径上的正向流量（如果可以的话，即正向边在E中），
或者减少反向流量（如果正向边不再E中，即该路径出现是因为在原网络中出现反向流量，
才使得残留网络中出现一条正向边）。

`
for each edge(u,v) ∈ G.E
	(u,v).f = 0
while there exists a path p from s to t in the residual network Gf
	cf(p) = min{cf(u,v): (u,v) is in p}
	for each edge(u,v) in p
		if(u,v) ∈ E
			(u,v).f += cf(p)
		else
			(v,u).f -= cf(p)
`

这个算法的问题是每次增减的容量cf(p)很小但最大流很大时，有可能会非常慢。
这取决于第一条找到的路径的容量是否总是很小，时间复杂度为O(E|f|)。

这里利用到了[Google tex 公式API](http://chart.apis.google.com/chart?cht=tx&chl=\Pi)